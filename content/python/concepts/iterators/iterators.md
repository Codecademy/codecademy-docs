---
Title: 'Iterators'
Description: 'In python, Iterator is a representation(an object) of a collection of elements(such as data or methods), from which one can access each element by traversing through it to perform the required tasks.'
Subjects:
  - 'Computer Science'
  - 'Data Science'
Tags:
  - 'Iterators'
  - 'OOP'
  - 'Loops'
CatalogContent:
  - 'learn-python-3'
  - 'paths/computer-science'
  - 'paths/data-science'
---

## Iterator

**Iterator** is a representation(an object) of a collection of elements(such as data or methods), from which one can access each element by traversing through it to perform the required tasks. A iterator supports inbuild `next()` method or user defined methods of similar kind that takes no arguments and always returns the next element of the collection, when all elements are exhausted it returns `StopIteration` exception.

## Iterables

The objects that can be converted into iterators are called **iterables**. The datatypes such as lists, tuples, dictionaries, sets are **iterable** these can be converted into iterators using inbuilt `iter()` method, the difference between **iterable** and **iterator** can be easily by understood by considering iterable as a birthday cake before cutting, as we need to distribute to all the people we cut cake into several pieces using `iter()` method to get iterator then we use `next()` to distribute each piece.

Also, it is important to understand that all iterators are iterable but the converse is not true.

## Code for Iterator using list

The following code shows generation of **iterator** from list using `iter()` and usage of the `next()` method by manually iterating through all the items of iterator. Finally when there are no more elements left in iterator, it returns the StopIteration Exception.

**Note**: A iterator once iterated through, cannot be re-iterated again.

```codebyte/py
#defining list cake, which is iterable
cake = ["piece1", "peice2", "peice3"] 

#converting list into iterator using iter() method
cake_ready_to_distribute = iter(cake)

#iterating through iterator, returns peice1
print(next(cake_ready_to_distribute))

#iterating through iterator, returns peice2
print(next(cake_ready_to_distribute))

#iterating through iterator, returns peice3
print(next(cake_ready_to_distribute))

#iterating through iterator, returns stopiteration exception
try:
    print(next(cake_ready_to_distribute))
except StopIteration:
    print("stop iteration error")
```
## Iterator in `for` loop

The `for` loop has inbuilt `iter()` and `next()` methods for it, which runs iterations in a more elegant way

```codebyte/py

#defining list cake, which is iterable
cake = ["piece1", "piece2", "piece3"] 

#initiating for loop
#the for loop itself convert iterable into iterator and returns elements
for piece in cake:   
  print(piece)

```
## Iteration using `while` loop

The `while` does not have the inbuild `iter()` and `next()` methods as in `for` loop, so the we need to use `iter()` and `next()` methods separately.

```codebyte/py

#defining list cake, which is iterable
cake = ["piece1", "peice2", "peice3"] 

#converting list into iterator using iter() method
cake_ready_to_distribute = iter(cake)

# initiated a infinite loop which stops when the iterator is exhausted
while True :
   try:
      #printing the next piece
      print(next(cake_ready_to_distribute))
  except StopIteration:
      # if StopIteration is raised, break from loop
      break

```
Till now we saw Iterators genarated by build-in in iterable ojects such as lists, to get a full grasp of concept lets see iterators generated by user-defined iterable objects.

## Creating a user-defined iterable object

Recall iterable object is an object that can be converted into Iterator, so for an object to be iterable it need to support `iter()` method and the iterator genarated also support `next()`.

```codebyte/py
class cake:
 
    def __init__(self, maxPieces=0):
        self.maxPieces = maxPieces

    def __iter__(self):
        self.piece = 0
        return self

    def __next__(self):
        if self.piece < self.maxPieces: 
                self.piece += 1                        
                return "piece"+str(self.piece)
        else:
            raise StopIteration


# creating object cake along with number of pieces to be distributed
cake_before_cutting = cake(10)

# the object cake is iterable as we defined iter method 
cake_after_cutting = iter(cake_before_cutting)

while True:
 
    try:
        # printing next piece 
        print(next(cake_after_cutting))
        
    except StopIteration:
        # if StopIteration is raised, break from loop
        break
```
From the above code one can observe how `next()` and `iter()` method are defined for an oject to be iterable.